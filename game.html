
<!DOCTYPE html>
<!--suppress ALL -->
<html lang="en">
<head>
    <title>Tic Tac Toe : AlpineJS by Scott Windon </title>
    <meta charset="UTF-8"> <!-- Character Encoding -->
    <!-- Required Meta Tags -->
    <meta content="width=device-width, initial-scale=1"
        name="viewport"> <!-- Responsive Design -->
    <!-- Recommended Meta Tags -->
    <meta content="Example AlpineJS Tic Tac Toe: Scott Windon"
        name="description"> <!-- SEO Meta Description -->
    <meta content="your, tags"
        name="keywords"> <!-- SEO Keywords -->
    <meta content="author name"
        name="author"> <!-- Author Information -->
    <!-- Links to CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="docs/assets/css/style.css"
        rel="stylesheet">
    <script defer src="https://cdn.jsdelivr.net/npm/alpinejs@3.13.3/dist/cdn.min.js"></script>
</head>
<!--                                                                         -->
<body>
<!--suppress GrazieInspection -->
<div class="min-w-screen min-h-screen bg-gray-800 flex items-center justify-center px-5 py-5">
    <!--
        The x-data directive is used to create a new instance of the gameApp object;
            - using an assignment to a local variable.
    -->
    <div class="w-96 h-96 mx-auto text-indigo-500 rounded-md flex flex-wrap relative"
        title=""
        x-data="{ game: board }" x-init="console.log('Game Board: Init:', board );">
        <!--suppress GrazieInspection -->
        <div class="flex w-full h-1/3">
        <!--
            The x-for directive is used to create, via grid array loops, & display the game grid's first row.
            The x-text directive is used to display the value of the item in the grid array.
            The x-show directive is used to hide the value of the item in the grid array.
            The x-transition directive is used to animate the display of the value of the item in the grid array.
        -->
            <template x-for="(item, index) in game.grid.slice(0,3)" :key="index">
                <div class="border-b border-gray-700 w-1/3" :class="{'border-l':index>0}"
                    x-data="{
                        current: $root.game,
                        DEBUG: {
                            FLAG: true,
                            LEVEL: 1
                        },

                        /**
                        * @function showCELL
                        **/
                        CELL: function(index, slot, empty = null,debug = false, level = 0){
                            slot._console('CURRENT CELL: ', debug, level, index, slot, empty);
                            return {
                                show: slot.currentCELL(index) !== empty,
                                print: slot.currentCELL(index)
                            }
                        },
                        makeMove: function(index, current, debug = false, level = 0){
                            // Select the item in the grid array at the specified index
                            const move = current.select(index, debug, level);
                            let slot = current.currentCELL(index);
                            // Update and set the current cell to the selected item: either P1 or a P2 token
                            slot = move.cell;
                            current.CELL(index) = slot;
                            // Log to the console the current move
                            current._console('ON-CLICK:MOVE: ', debug, level, current, index, slot, move);
                        }
                    }">
                    <button class="w-full h-full outline-none focus:outline-none text-8xl leading-none"
                            @click.prevent="
                                // Fire and make move on each user' click event per index.
                                makeMove(index, current, DEBUG.FLAG, DEBUG.LEVEL)
                                /**
                                 * The $nextTick method is used to wait for the DOM to be updated
                                 * before updating the grid array with the selected item.
                                 * Combined with Alpine.reactive() on the game.grid array in App class.
                                 * @url https://alpinejs.dev/magics/nextTick
                                 * @url https://alpinejs.dev/advanced/reactivity
                                 */
                                this.$nextTick(() => {
                                    current.CELL[index] = current.currentCELL(index);;
                                    current._console('UPDATE GRID:$nextTick:',
                                                     DEBUG.FLAG, DEBUG.LEVEL,
                                                     current.currentCELL(index));
                                    })
                                ">
                        <!--suppress XmlUnboundNsPrefix -->
                        <!--
                            The x-show directive: showing the game.grid[index] value when the grid is not null.
                            The x-text directive: displaying the game.grid[index] value when the grid is not null
                                - Default: x-text is assigned on template/#doc-fragment rendering.
                                - x-text does not automatic DOM update.
                            The x-transition directive is used to animate the display of the value of the item in
                            the grid array.
                        --->
                        <span class="inline-block"
                            x-show="CELL(index, current, DEBUG.FLAG, DEBUG.LEVEL).show"
                            x-text="CELL(index, current).print"
                            x-transition:enter="transition ease-out duration-300"
                            x-transition:enter-start="opacity-0 transform scale-50"
                            x-transition:enter-end="opacity-100 transform scale-100"></span>
                    </button>
                </div>
            </template>
        </div>
        <div class="flex w-full h-1/3">
            <!--
            ➖ The AlpineJS x-for directive: to create, via grid array loops, & display the game grid's third row.
            ➖ Loops on the AlpineJs key: index and creates a row for cells 4 to 6 as clickable buttons.
            ➖ @click event: to select the item in the grid array at the specified index
            -->
            <template x-for="(item, index) in game.grid.slice(3,6)" :key="index">
                <div class="border-b border-gray-700 w-1/3" :class="{'border-l':index>0}">
                    <button class="w-full h-full outline-none focus:outline-none text-8xl leading-none"
                            @click.prevent="
                                game.grid[index+3] = game.select(index+3),
                                this.$nextTick(() =>
                                    game.grid[index+3] = game.grid[index+3],
                                    // Logging Confirm of successful event update
                                    console.log('grid update:', game.grid[index+3])
                                )">
                        <span class="inline-block"
                            x-show="game.grid[index+3]!==null" x-text="game.grid[index+3]"
                            x-transition:enter="transition ease-out duration-300"
                            x-transition:enter-start="opacity-0 transform scale-50"
                            x-transition:enter-end="opacity-100 transform scale-100"></span>
                    </button>
                </div>
            </template>
        </div>
        <div class="flex w-full h-1/3">
            <!--
            ➖ The AlpineJS x-for directive: to create, via grid array loops, & display the game grid's third row.
            ➖ Loops on the AlpineJs key: index and creates a row for cells 7 to 9 as clickable buttons.
            ➖ @click event: to select the item in the grid array at the specified index
            -->
            <template x-for="(item, index) in game.grid.slice(6, 9)" :key="index">
                <div class="border-b border-gray-700 w-1/3" :class="{'border-l':index>0}">
                    <button class="w-full h-full outline-none focus:outline-none text-8xl leading-none"
                            @click.prevent="
                                game.grid[index+6] = game.select(index+6),
                                this.$nextTick(() =>
                                    game.grid[index+6] = game.grid[index+6],
                                    // Logging Confirm of successful event update
                                    console.log('grid update:', game.grid[index+6])
                                )
                            ">
                        <span class="inline-block"
                            x-show="game.grid[index+6]!==null" x-text="game.grid[index+6]"
                            x-transition:enter="transition ease-out duration-300"
                            x-transition:enter-start="opacity-0 transform scale-50"
                            x-transition:enter-end="opacity-100 transform scale-100"></span>
                    </button>
                </div>
            </template>
        </div>
        <button class="absolute top-0 left-0 w-96 h-96 flex items-center justify-center outline-none focus:outline-none"
                style="display:none;"
                x-show="game.WON()||game.TURNS()>=9"
                x-transition:enter="transition ease-out duration-300"
                x-transition:enter-start="opacity-0 transform scale-50 rotate-12"
                x-transition:enter-end="opacity-100 transform scale-100 rotate-0"
                @click.prevent="game.reset()">
            <span class="block transform -rotate-12 text-white text-9xl text-glow-xl"
                x-text="game.WON()?'Winner!':'😔'"></span>
        </button>
    </div>
</div>


<!-- BUY SCOTT WINDON (originator of version 1 and concept) A BEER AND HELP SUPPORT OPEN-SOURCE RESOURCES -->
<!-- Accreditation for External Source Code, as foundational code for this project. -->
<div class="flex items-end justify-end fixed bottom-0 right-0 mb-4 mr-4 z-10">
    <div>
        <a class="block w-16 h-16 rounded-full transition-all shadow hover:shadow-lg transform hover:scale-110 hover:rotate-12"
           href="https://www.buymeacoffee.com/scottwindon" target="_blank"
           title="Buy me a beer: Scott Windon">
            <img class="object-cover object-center w-full h-full rounded-full"
                src="https://i.pinimg.com/originals/60/fd/e8/60fde811b6be57094e0abc69d9c2622a.jpg" alt="Buy ScottWindon a Coffee; tracker"/>
        </a>
    </div>
</div>

<script>

    class GameLogic {
        /**
         * @constructor
         * @param {boolean} [debug=this.DEVMODE] - Optional Flag to enable debug mode.
         * @param {number} [level=this.LOGLEVEL] - Optional level of logging to console.
         * Constructor for the App class.
         * Uses Class Constants to initialises values.
         * Initializes the App object with default values and reactivity for:
         * - turns counters & turn properties
         * - win or draw state,
         * - win sequences/combinations,
         * - game grid & current cell,
         * - x & o characters,
         * The constructor also logs the instantiation of the App object to the console.
         * @returns {void}
         */
            // noinspection FunctionNamingConventionJS

        static _EMPTYCELL = null

        constructor(debug = false, level = 0) {
            // Enable Developer Mode for debugging
            this.DEBUG = typeof mode === 'boolean' ? debug : this.DEVMODE
            this.LEVEL = typeof type === 'number' ? level : this.LEVEL
            // Instance variables set by Class Constants
            /** @instance CONSTANT */
            // Set initial class constants empty cell.
            /** @instance private */
            this._turns = GameLogic.TURN_INIT
            this._currentcell = GameLogic.CELL_RESET
            /** @instance private */
            this._grid = GameLogic.NEW_GRID
            /** @instance private */
            this._draw = GameLogic.NO_DRAW // The default check win state of the game / Set initial constants
            /** @instance private */
            this._won = GameLogic.IN_PLAY // The default check win state of the game / Set initial constants
            /** @instance private */
            this._winSeq = GameLogic.WIN_COMBINATIONS // Set initial class constants
            /** @instance private
             * @type {array} */
            this._xChars = GameLogic.P1_TOKENS
            // noinspection JSUnresolvedReference
            /** @instance  private */
            this._oChars = GameLogic.P2_TOKENS
            /** @instance  private Track the length/number of X's played */
            this._xTurns = GameLogic.TURN_RESET // Set initial class constants
            /** @instance private Track the length/number of Y's played */
            this._oTurns = GameLogic.TURN_RESET // Set initial class constants
            this._console('Instantiate Game Logic: ', this.DEBUG, this.LEVEL, this) // jshint ignore:line
        }
        // =========================================== PROPERTY GET/SET | CLASS DEBUG MODE ===============================

        /**
         * Retrieves the current value of the DEVMODE property.
         * @property {boolean} DEVMODE
         * @public
         * @returns {boolean} The current value of the DEVMODE property.
         * @default false
         */
        get DEVMODE() {
            return false
        }

        /**
         * Sets the developer mode toggle.
         * @property {boolean} DEVMODE
         * @public
         * @param {boolean} toggle - The value to set the developer mode toggle.
         * @default {boolean} false` if `toggle` is undefined.
         */
        set DEVMODE(toggle = false) {
            const _disabled = false // disabled by default or if omitted
            // When true, enabled debug mode
            this.DEBUG = typeof toggle === 'boolean' ? toggle : _disabled
        }

        /**
         * Retrieves the current value of the DEVMODE property.
         * @property {number} LOGLEVEL property
         * @public
         * @returns {number} The current value of the DEVMODE property.
         * @default 0
         */
        get LOGLEVEL() {
            return this.LEVEL === undefined ? 0 : this.LEVEL
        }

        /**
         * Sets the developer mode toggle.
         * @property {number} LOGLEVEL
         * @public
         * @param {number} consolelevel - The value to set the developer mode toggle.
         * @default {boolean} false` if `toggle` is undefined.
         */
        set LOGLEVEL(consolelevel = 0) {
            const _disabled = 0 // disabled by default or if ommited
            this.LEVEL = typeof consolelevel === 'number' ? consolelevel : _disabled
        }

        // =========================================== PROPERTY STATIC GETTERS | CLASS Constants =========================

        /**
         * Gets the Player 1 Token.
         * @property {string} P1 Player 1 Token
         * @private
         * @returns {string} The name of the property for turns.
         * @static, Class constants
         * @default 'X'
         */
        static get P1() {
            return 'X'
        }

        /**
         * Get the P1 tokens.
         * @property P1_TOKENS
         * @private
         * @returns {string[]} The P1 tokens.
         */
        get P1_TOKENS() {
            return ['x', 'X']
        }

        /**
         * Gets the Player 1 Token.
         * @property {string} P2 Player 2 Token
         * @private
         * @returns {string} The name of the property for turns.
         * @static, Class constants
         * @default 'O'
         */
        // noinspection FunctionNamingConventionJS
        static get P2() {
            return 'O'
        }

        /**
         * Get the P2 tokens.
         * @property {Array} P2_TOKENS
         * @private
         * @returns {string[]} The P2 tokens.
         */
        get P2_TOKENS() {
            return ['o', 'O']
        }

        /**
         * Returns the length of the search string used in regular expression.
         * @property {number} _REG_SEARCH_LENGTH
         * @private
         * @access private
         * @default {number} 3 Number of winning moves
         * @returns {number} The length of the search string.
         */
        static get REG_SEARCH_LENGTH() {
            return 3
        }

        /**
         * Returns the regular expression flag used to perform a global search.
         * @property {string} _REG_SEARCH_FLAG
         * @private
         * @access private
         * @default {string} g: means regular expression will look for all instances rather than
         *     stopping at the 1st instance. e - ['g'] The mode to use for the regular expression. G is
         *     a global search.
         * @returns {string} The regular expression flag for global search.
         */
        static get REG_SEARCH_ALL() {
            return 'g'
        }

        /**
         * Retrieves the REG_SEARCH_FILTER constant.
         * @function REG_SEARCH_FILTER
         * @private
         * @access private
         * @default {string} ''
         * @return {string} The REG_SEARCH_FILTER constant string.
         */
        static get REG_SEARCH_FILTER() {
            return ''
        }

        /**
         * Returns an array of winning combinations on a Tic-Tac-Toe board.
         * The combinations are represented by strings of three positions on the board.
         * Each position is denoted by a number from 0 to 8, indicating the index of the position on
         * the board array. The winning combinations consist of three positions that form a winning
         * row, column, or diagonal on the board.
         * @property {Array} WIN_COMBINATIONS
         * @private
         * @return {Array} The array of winning combinations.
         * @static, Class constant
         */
        static get WIN_COMBINATIONS() {
            return [
                '012',
                '345',
                '678', // HorizontalWins
                '036',
                '147', // DiagonalWins
                '258',
                '048',
                '246',
            ]
        }

        /**
         * Retrieves the value of the "_winSeq" property.
         *
         * @returns {any} The value of the "_winSeq" property.
         */
        get WIN_SEQUENCE() {
            return this._winSeq
        }

        /**
         * Retrieves the initial state of a drawn game.
         * @property {boolean} NO_DRAW -  Initial State of a drawn game, a viable initial state.
         * @private
         * @return {boolean} -  Initial State of a drawn game, a viable initial state.
         * @static, Class constant
         * @default false
         */
        static get NO_DRAW() {
            return false
        }

        /**
         * Retrieves the current as an end state of the game.
         * @property {boolean} HAS_DRAW -  Whether the game has drawn, a viable end state.
         * @private
         * @return {boolean} - Whether the game has drawn, a viable end state.
         * @static, Class constant
         * @default true
         */
        static get HAS_DRAW() {
            return true
        }

        /**
         * Retrieves the current state of the game.
         * @property {boolean} IN_PLAY - The inital/current state of the game when not won.
         * @private
         * @return {boolean} - Whether the game is currently in play or not.
         * @static, Class constant
         * @default false
         */
        static get IN_PLAY() {
            return false
        }

        /**
         * Returns the reset value for the cell.
         * @property {null} CELL_RESET
         * @private
         * @returns {null} The reset value for the cell.
         * @static, Class constant
         * @default null
         */
        static get CELL_RESET() {
            return null
        }

        /**
         * Retrieves the value representing the turn reset.
         * @property {string} TURN_RESET
         * @private
         * @returns {string} The value representing the turn reset.
         * @static, Class constant
         */
        static get TURN_RESET() {
            return ''
        }

        /**
         * Gets the name of the property for keeping track of turns:
         * i.e. the string/number of move sequences made by the player.
         * @property {string} X_TURNS_PROP
         * @private
         * @returns {string} The name of the property for X turns.
         * @static, Class constant
         * @default '_oTurn' - The name of this._oTurns
         * @called: _updateTurns | _updateTurnsAndGrid
         */
        // noinspection FunctionNamingConventionJS
        static get X_TURNS_PROP() {
            return '_xTurn'
        }

        /**
         * Gets the name of the property for keeping track of turns:
         * i.e. the string/number of move sequences made by the player.
         * @property {string} O_TURNS_PROP
         * @private
         * @returns {string} The name of the property for O turns.
         * @static, Class constant
         * @default '_oTurn' - The name of this._oTurns
         * @called: _updateTurns _updateTurnsAndGrid
         */
        // noinspection FunctionNamingConventionJS
        static get O_TURNS_PROP() {
            return '_oTurn'
        }

        /**
         * Returns the maximum (array/grid cell) length allowed for the grid
         * @property {number} MAX_LENGTH
         * @private
         * @returns {number} The maximum length allowed.
         * @static, Class constant
         * @default 9 - max size of a game of tic tac toe
         */
        // noinspection FunctionNamingConventionJS
        static get MAX_LENGTH() {
            return 9
        }
        /**
         * Returns the initialisation value for turns.
         * @property {number} TURN_INIT
         * @private
         * @returns {number} The value for TURN_INIT.
         * @static, Class constant
         * @default 0 - Initialisation for turns.
         */
        // noinspection FunctionNamingConventionJS
        static get TURN_INIT() {
            return 0
        }

        // =========================================== PROPERTY PUBLIC GETTERS ===========================================

        /**
         * Returns the current grid, as-is.
         * @property {*[]|null[]|array} GRID
         * @access public
         * @returns {*[]|null[]|array} The value for private _grid.
         */
        get GRID() {
            return this._grid
        }

        // noinspection FunctionWithInconsistentReturnsJS
        /**
         Sets / updates the current grid, as-is, with an shallow copy overwrite of primitives.
         * @property {*[]|null[]|array} GRID
         * @access public
         * @returns {*[]|null[]|array} The value for private _grid.
         */
        set GRID(updateGrid) {
            if (Array.isArray(updateGrid)) {
                // Assign this array to the _grid property
                this._grid = Array.from(updateGrid);
            } else if (typeof updateGrid === 'object' && updateGrid !== null) {
                // updateGrid is an object (not null), create a new grid
                this._grid = this.NEW_GRID;
            }
        }

        /**
         * Creates a new grid with the specified max, filled with the reset cell value.
         * @property {null[]|Array<null>} NEW_GRID
         * @access private: internal use only
         * @return {null[]|Array<null>} The new grid with the specified length, filled with the reset cell value.
         */
        get NEW_GRID() {
            // noinspection ChainedFunctionCallJS
            return new Array(GameLogic.MAX_LENGTH).fill(GameLogic.CELL_RESET)
        }

        /**
         * Set a new grid for the object, for constructor(), and reset().
         * @property {*[]|null[]} NEW_GRID
         * @access private: internal use only
         * @param {*[]|null[]} grid - The new grid to be set. Must be an array.
         */
        set NEW_GRID(grid) {
            this._grid = grid === undefined ? this.NEW_GRID : grid
        }
        /**
         * Retrieves the current status of the game as a draw
         * @property {boolean} IFDRAWN
         * @public
         * @access public
         * @default false: false on initialisation/reset. True if game is drawn.
         * @returns {boolean} - Indicates whether the drawing is in progress or not.
         *
         */
        get IFDRAWN() {
            return this._draw
        }

        /**
         * Sets the value of IFDRAWN.
         * @property {boolean} IFDRAWN
         * @public
         * @access public
         * @default {boolean} false:
         *   - False on initialisation/reset, no draw.
         *   - True if end game is drawn/no winner.
         * @param {boolean} value - The new value for IFDRAWN.
         * @return {void} - The new value for IFDRAWN.
         */
        set IFDRAWN(value) {
            this._draw = typeof value === 'boolean' ? value : GameLogic.NO_DRAW
        }

        /**
         * Returns the default value for WIN state or winning Player for instance variable _won.
         * @property {boolean|string} IFWON
         * @access public
         * @returns {boolean|string} The value for private instance member _won.
         * @default {boolean} false
         *   - False on initialisation/reset.
         *   - GameLogic.P1 | GameLogic.P2 if game is won. Winning Player's Token
         */
        get IFWON() {
            if (typeof this._won === 'string') {
                return this._won
            }
            return this._won === GameLogic.IN_PLAY ? GameLogic.IN_PLAY : this._won
        }

        /**
         * Sets the value for _won.
         * @property {boolean, string} IFWON
         * @access public
         * @param {boolean, string} value The value to set for _won.
         * @default {boolean} false
         *   - False on initialisation/reset.
         *   - GameLogic.P1 | GameLogic.P2 if game is won. Winning Player's Token
         * @return {void}
         */
        set IFWON(value) {

            const players = [GameLogic.P1, GameLogic.P2];
            // noinspection AnonymousFunctionJS,NestedFunctionCallJS
            const isPlayerOneOrTwo = players.some(player =>
                                                      value.toUpperCase() === player.toUpperCase());

            if (typeof value === 'string' && isPlayerOneOrTwo) {
                this._won = value;
            }
            else if (typeof value === 'boolean') {
                this._won = value;
            }
            else { // Fail-over to false if value is not string or boolean
                this._won = GameLogic.IN_PLAY;
            }
        }

        /**
         * Returns the (initialisation/current value for turns.
         * @property {number} TURNS
         * @access public
         * @returns {number} The value for current private _turns.
         */
        get TURNS() {
            return this._turns
        }

        /**
         * Returns the maximum turn value. Array length - 1.
         * @property {number} MAX_TURNS
         * @access public
         * @return {number} The maximum turn value.
         */
        get MAX_TURN() {
            const ceiling = 1
            return this._grid.length - ceiling
        }

        /**
         * Retrieves the value of a cell in the grid based on a given index.
         * @function currentCELL accessor function
         * @param {number} index - The index of the cell to retrieve.
         * @return {string|null} - The value of the cell at the specified index.
         */
        currentCELL(index) {
            if (this._validCell(index)){
                this._currentcell = this._grid[index];
                return this._currentcell;
            }
            return null;
        }

        /**
         * Checks if the given index is a valid cell in the grid.
         * @function _validCell accessor function
         * @private
         * @param {number} index - The index to check.
         * @return {boolean} - Returns true if the index is a valid type, and a valid cell, false otherwise.
         * @called: currentCELL
         */
        _validCell(index) {
            return typeof index === 'number' && ( index < this._grid.length && index >= 0)
        }

        /**
         * Retrieves the value of the current cell.
         * @property {string} CELL
         * @access public
         * @returns {string} The value of the current cell.
         */
        get CELL() {
            return this._currentcell
        }

        /**
         * Sets the value of instance property cell in the grid based on a given index, & updates the
         * current grid at index.
         * @property {number} CELL - The grid's index of the cell to set.
         * @access public
         * @param {number} index - The index of the cell to set.
         * @param {string} value - The value to set the cell to.
         * @return {void}
         */
        set CELL(index, value) {
            // Only update the current cell if the value is a string
            if (value !== undefined && typeof value === 'string' && typeof index === 'number') {
                this._currentcell = value
                this._grid[index] = this._currentcell
            }
        }

        // =========================================== PRIVATE FUNCTIONS: HELPERS =======================================

        /**
         * Logs a message to the console based on the specified debug and verbosity level.
         * @design LOGGING TO CONSOLE IS AN INTENTIAL DESIGN FEATURE THAT IS CONTROLED BY THE DEBUG
         *     MODE & VERBOSITY FLAG.
         * @function _console logger according to debug mode and verbosity level
         * @private
         * @access private
         * @param {string} message - The message to be logged.
         * @param {boolean} [debug=this.DEVMODE] - Optional Flag to enable debug mode.
         * @param {number} [level=this.LOGLEVEL] - Optional level of logging to console.
         * @param {...any} [args] - Additional arguments to be passed to the console methods.
         * @return {void}
         * @desc It takes in four parameters: message, debug, level, and args.
         * It checks if debug is enabled, and if it is, it outputs the message to the console based on
         *     the verbosity level.
         * Verbosity level 0: Clears the console (default)
         * Verbosity level 1 [LOGS]: Logs the message to the console.
         * Verbosity level 2 [DEBUG]: Logs the message to the console using console.debug.
         * Verbosity level 3 [TRACE]: Logs the message to the console using console.trace.
         * Verbosity level 4 [WARN]: Logs the message to the console using console.warn.
         * Verbosity level 5 [ERROR]: Logs the message to the console using console.error.
         * Verbosity level 6 [OBJECT]: Logs the message to the console using console.dir.
         */
        _console(
            message,
            debug = this.DEVMODE,
            level = this.LOGLEVEL,
            ...args
        ) {
            // check if debug is enabled
            if (!debug) {
                return
            }

            // output messages based on verbosity level
            switch (level) {
                case 1:
                    console.log(message, ...args)
                    break
                case 2:
                    console.debug(message, ...args)
                    break
                case 3:
                    console.trace(message, ...args)
                    break
                case 4:
                    console.warn(message, ...args)
                    break
                case 5:
                    console.error(message, ...args)
                    break
                case 6:
                    console.info(message, ...args)
                    console.dir(...args)
                    break
                default:
                    // do nothing for default. If true, and level is not used, clears the console.
                    if (debug && level === 0) {
                        console.clear()
                    }
            }
        }

        // ========================== =========================== ===================================
        // ========================== PRIVATE FUNCTIONS: SELECT() ===================================
        // ========================== =========================== ===================================

        /**
         * Returns a random character from the given character array.
         * @design
         *  This randomiser allows variation of the game token sizes (lower case/upper case).
         *  It mimics variation in hand strokes when hand drawing the game tokens.
         * @function _getRandomCharacter
         * @private
         * @access private
         * @internal @function _getRandomIndex
         * @param {Array} characterArray - The array containing characters.
         * @param {boolean} [debug=this.DEVMODE] - Optional Flag to enable debug mode.
         * @param {number} [level=this.LOGLEVEL] - Optional level of logging to console.
         * @return {string} - A random character from the character array.
         */

        // noinspection FunctionNamingConventionJS
        _getRandomCharacter(
            characterArray,
            debug = this.DEVMODE,
            level = this.LOGLEVEL
        ) {
            // noinspection LocalVariableNamingConventionJS,NestedFunctionCallJS
            /** An inner function/closure for generating a random index. Improve maintainability/readability.
             * @function {arrow function} _getRandomIndex
             * @param {number} arrayLength
             * @return {number} - A random index.
             */
            const _getRandomIndex = arrayLength => Math.floor(Math.random() * arrayLength)
            const index = _getRandomIndex(characterArray.length)
            this._console(
                'getRandomCharacter: ',
                debug,
                level,
                characterArray,
                index,
                characterArray[index]
            )
            return characterArray[index]
        }

        // noinspection OverlyComplexFunctionJS
        /**
         * Update the current instance turn property, per current cell/token, with latest move/cell ref.
         * @function _updateTurn
         * @private
         * @param {number} selectCellRef - The index (ref) of the selected cell.
         * @param {string} currentCell - The cell current value.
         * @param {string} activeToken - The active Token (X or O) constant.
         * @param {string} turnProp - The current player record.
         * @param {boolean} [debug=this.DEVMODE] - Optional Flag to enable debug mode.
         * @param {number} [level=this.LOGLEVEL] - Optional level of logging to console.
         * @return {string} - The updated player record.
         */

        _updateTurn(
            selectCellRef,
            currentCell,
            activeToken,
            turnProp,
            debug = this.DEVMODE,
            level = this.LOGLEVEL
        ) {
            const moveRef = (currentCell.toUpperCase() === activeToken.toUpperCase()) ?
                selectCellRef : '';
            if (typeof moveRef === 'number') {
                this[turnProp] += moveRef.toString();
            }
            this._console.log('Update Turn: ', debug, level,
                              selectCellRef, currentCell, activeToken, turnProp, this[turnProp])
            return turnProp;
        }


        /** Update the turns and grid at the specified index
         * with a random character from the characterArray.
         * @function _updateTurnsAndGrid
         * @private
         * @access private
         * @calls _getRandomCharacter
         * @calls _updateTurn
         * @param {number} index - The index of the grid to update.
         * @param {string[]} characterArray - The array of characters to choose from.
         * @param {string} turnProperty - The property to update the turns with.
         * @param {boolean} [debug=this.DEVMODE] - Optional Flag to enable debug mode.
         * @param {number} [level=this.LOGLEVEL] - Optional level of logging to console.
         * @return {void}
         * @desc It takes in three parameters: index, characterArray, and turnProperty.
         * It updates the grid array at the specified index with a random character from the
         *     characterArray and ... increments the value of the turnProperty by index.
         * @complexity 13%
         **/


        _updateTurnsAndGrid(
            index,
            characterArray,
            turnProperty,
            debug = this.DEVMODE,
            level = this.LOGLEVEL
        ) {

            // Set the current CELL (grid item) to a random character from the characterArray
            this.CELL[index] = this._getRandomCharacter(characterArray)
            // Update the sequence of moves via appending the turnProperty by selected index
            const _activeToken = turnProperty === GameLogic.X_TURN_PROP ?
                GameLogic.P1 : GameLogic.P2;
            const currentSequence = this._updateTurn(index,
                                                     this.CELL,
                                                     _activeToken,
                                                     turnProperty);

            // Update the corresponding turns property based on activeToken
            switch(activeToken) {
                case GameLogic.P1:
                    this._xTurns = currentSequence;
                    break;
                case GameLogic.P2:
                    this._oTurns = currentSequence;
                    break;
                default:
                // You can add some default behaviour here if needed.
            }

            this._console(
                'updateTurnsAndGrid: ',
                debug,
                level,
                index,
                characterArray,
                _activeToken,
                turnProperty,
                activeTurnValue,
                this[turnProperty],
                this.CELL
            )
        }

        /**
         * Checks if the given move is invalid.
         * @design
         *   - Has an inner function to DRY check the multiple invalid states:
         *      1) If Won, or 2) If Cell is not empty, or 3) IF turn COUNT is greater than or equal to
         *     playable MAX_TURNs.
         *       - Use as a flag to check for type of moves (invalid or valid) and to return the
         *     current state of the game.
         *   - Logs to console the function parameters and return values for debugging purposes when
         *     debug mode is enabled.
         * @function _isInvalidMove
         * @private
         * @access private
         * @internal @function __hasInvalidState
         * @param {number} index - The index of the move.
         * @param {boolean} [debug=this.DEVMODE] - Optional Flag to enable debug mode.
         * @param {number} [level=this.LOGLEVEL] - Optional level of logging to console.
         * @returns {boolean} - Returns true if the move is invalid, false otherwise.
         * @description Checks if a given move is invalid. The function takes an index as an argument
         *     and returns true if the move is invalid, and false otherwise. The move is considered
         *     invalid if any of the following conditions are met: the game is already won, the grid at
         *     the given index is not null, or the number of turns is greater than or equal to the
         *     maximum index.
         * @complexity 6%
         */
        _isInvalidMove(
            index,
            debug = this.DEVMODE,
            level = this.LOGLEVEL
        ) {

            /**  Inner function declaration (restrict for scope)
             * Determines if the current state is invalid.
             * @function _hasInvalidState
             * @param {number} index - The index of the cell.
             * @param {number} max_turn - The maximum number of turns allowed.
             * @param {null} empty - The value of the empty cell.
             * @return {boolean} - True if the current state is invalid, false otherwise.
             */
            const __hasInvalidState = (index, max_turn,
                                       empty = null) => {
                return (
                    this.IFWON ||
                    this.CELL !== empty || // if not null, truthy for false
                    this.TURNS >= max_turn
                ) // More than max turns, truthy for false
            }
            // Log to Function Params to Console for debugging purposes when debug mode is enabled.
            this._console(
                'isInvalidMove:❓: ', debug, level,
                index,
                this.IFWON,
                this.CELL,
                this.TURNS,
                this.MAX_TURN
            )
            // Checks the current state for invalidity from inner function
            const ifInvalidMove = __hasInvalidState(index,
                                                    this.MAX_TURN)
            // Log to Function Return to Console for debugging purposes when debug mode is enabled.
            this._console('isInvalidMove:✅: ',
                          debug, level, ifInvalidMove)
            return ifInvalidMove
        }

        /**
         * Determines if the turn is even and updates the turns and grid accordingly.
         * @design:
         *  - Uses anonymous arrow functions to DRY the code over direct const assignments.
         *  - Improve maintainability/readability.
         *  - Uses Modulus 2 to determine if the turn is even.
         *  - Uses a ternary operator to assign the character and property to be used.
         *  - Calls the _updateTurnsAndGrid method to update the turns and grid based the character and
         *     turn properties.
         *  - Logs to console the function parameters and return values for debugging purposes when
         *     debug mode is enabled.
         * @function _isEvenTurn
         * @private
         * @access private
         * @internal @function _isTurnEven
         * @internal @function _chooseChar
         * @internal @function _chooseProp
         * @calls @function _updateTurnsAndGrid
         * @param {number} index - The index of the grid to be updated.
         * @param {boolean} [debug=this.DEVMODE] - Optional Flag to enable debug mode.
         * @param {number} [level=this.LOGLEVEL] - Optional level of logging to console.
         * @return {void}
         * @desc determines if the turn is even and updates the turns and grid accordingly.
         * It takes an input parameter index which represents the index of the grid to be updated.
         * It calculates whether the turn is even by checking if the remainder of the division of
         *     `this._turns` by 2 is equal to 0. If the turn is even, it assigns certain values to
         *     variables char and prop.
         * @complexity 26%
         */
        _isEvenTurn(
            index,
            debug = this.DEVMODE,
            level = this.LOGLEVEL
        ){
            // Determines if the turn is even or odd.
            const __isTurnEven = () => {
                return this.TURNS % 2 === 0
            }
            // Chooses the character to be used
            const __chooseChar = () => {
                return __isTurnEven() ? this._xChars : this._oChars
            }
            // Selects the token to be used
            const __selectProp = () => {
                return __isTurnEven() ? GameLogic.X_TURNS_PROP : GameLogic.O_TURNS_PROP
            }
            // Assign the selector value per each turn.
            let chars = __chooseChar() // Select the character array per turn. X for odd or O for even
            let turnprop = __selectProp() // X Prop for odd or O Prop for even
            // Update the turns and grid
            this._updateTurnsAndGrid(index, chars, turnprop,
                                     debug, level)
            // Log to Function Return to Console for debugging purposes when debug mode is enabled.
            this._console('isEvenTurn:✅', debug, level,
                          _chooseChar, _selectProp, index, this.CELL) // jshint ignore:line
        }

        /**
         * Increments the value of the TURNS property by 1.
         * @function _incrementTurn
         * @private
         * @access private
         * @return {void}
         */
        _incrementTurn() {
            this._turns += 1
        }

        // ======================== ================================ ==================================
        // ========================    PUBLIC FUNCTIONS: SELECT()    ==================================
        // ======================== ================================ ==================================
        /**
         * Selects a cell, bu index, on the game board.
         * @design:
         *   - Main interface method for the user interface and game board.
         *   - Uses an inner function to DRY the code over direct const assignments.
         *   - Inner function is used to determine who wins based on the given index, and returns the
         *     state of the game.
         *   - Logs to console the function parameters and return values for debugging purposes when
         *     debug mode is enabled.
         *   - 3 Game States (on return): Based on a current cell, next play, game state and game
         *     message.
         *     - Invalid Move: Try again
         *     - Next Play: Game in play
         *     - Winning State: P1 or P2 wins
         * @function select
         * @public
         * @access public
         * @internal @function __whoWins
         * @internal @function __havValidMove
         * @param {number} index - The index of the cell to be selected.
         * @param {boolean} [debug=this.DEVMODE] - Optional Flag to enable debug mode.
         * @param {number} [level=this.LOGLEVEL] - Optional level of logging to console.
         * @returns {object}:
         *   - cell: The current cell at the given index. (X or Y Token)
         *   - next: The next action to take after the move.
         *   - message: A message describing the reason for the invalid move.
         *   - state: Indicates if the game is still ongoing (false) or if someone has won (true).
         *   - outcome: The outcome of the move (0 - invalid move, 1 - valid move)
         * @desc  It logs the selected index, checks if the move is invalid, and returns the game token
         *     for X or Y.
         *   - If the move is invalid, it logs an error message and returns the current item from the
         *     grid. //
         *   - If the move is valid, it updates the turns and grid, checks if the game has been won,
         *     logs a success message,
         *   - and returns the updated item/token from the grid.
         * @complexity 86%
         * */
        select(
            index,
            debug = this.DEVMODE,
            level = this.LOGLEVEL)
        {
            /**
             * Determines who wins based on the given index.
             * @design
             *  - Uses an inner function to DRY the code over direct const assignments.
             *  - Inner function simplifies the multipe end states of the valid move: 1) Game in play,
             *     2) Game won.
             *  - Returns: Current cell, next turn, game message v winner, game state and game outcome.
             *  - Logs to console the function parameters for debugging purposes when debug mode is
             *     enabled.
             * @private
             * @internal
             * @function _whoWins
             * @param {number} index - The index of the move being checked.
             * @param {boolean} debug - Indicates whether debug mode is enabled.
             * @param {number} level - The difficulty level of the game.
             * @returns {Object} - An object containing information about the validity of the move.
             *   - cell: The current cell at the given index.
             *   - next: The next action to take after the move.
             *   - message: A message describing the reason for the invalid move.
             *   - winner: The winner of the game.
             *   - state: Indicates if the game is still ongoing (false) or if someone has won (true).
             *   - outcome: The outcome of the move (0 - invalid move, 1 - valid move).
             */
            const __whoWins = ( index,
                                debug, level ) => {
                // Call checkWinner and assign result
                const winCheck = this.checkWinner()
                if (winCheck === GameLogiC.IN_PLAY) { // False
                    this._console('isWinner: ❌', debug, level,
                                  index, this.CELL, winCheck) // jshint ignore:line
                    return {
                        cell: this.CELL, // Current cell in play
                        next: 'Next Turn',
                        message: 'Game in play',
                        winner: 'None',
                        state: false, // Game is not won, continuing
                        valid: 1,
                        outcome: 0,
                    }
                } else {
                    this._console('isWinner: ✅', debug, level,
                                  index, this.CELL, winCheck) // jshint ignore:line
                    return {
                        cell: this.CELL, // Winning cell when played.
                        next: 'Game Over',
                        message: this.checkWinner() ? winCheck : 'No Winner',
                        winner: this.checkWinner() === GameLogic.P1 ? 'Player 1' : 'Player 2',
                        // When P1/P2 is returned the winner.
                        state: true, // Game is won, end game.
                        valid: 1,
                        outcome: 1,
                    }
                }
            }

            /**
             * Checks if a move is valid or not.
             * @design
             * @private
             * @internal
             * @function __hasValidMove
             * @param {number} index - The index of the move being checked.
             * @param {boolean} debug - Indicates whether debug mode is enabled.
             * @param {number} level - The difficulty level of the game.
             * @returns {Object} - An object containing information about the validity of the move.
             *   - cell: The current cell at the given index.
             *   - next: The next action to take after the move.
             *   - message: A message describing the reason for the invalid move.
             *   - state: Indicates if the game is still ongoing (false) or if someone has won (true).
             *   - outcome: The outcome of the move (0 - invalid move, 1 - valid move).
             */
            const __hasValidMove = (index,
                                    debug, level ) => {
                if (this._isInvalidMove(index)) {
                    // Invalid Moves: Try again.
                    this._console(
                        `Invalid Move: 🚧 for current ${this.CELL}`,
                        debug,
                        level,
                        index,
                        this.CELL
                    ) // jshint ignore:line
                    return {
                        cell: this.CELL,
                        next: 'Try again',
                        message: 'Invalid Move: Select a different/empty slot',
                        state: false, // Game is not won, continuing
                        valid: 0,
                        outcome: 2,
                    }
                } else {
                    // Valid Move: Proceed to next turn or declare winner.
                    // Update the turns and grid
                    this._incrementTurn()
                    this._isEvenTurn(index)
                    // Check if the game has been won
                    const isWinner = __whoWins( index,
                                                debug, level)
                    // Return the updated item from grid
                    this._console(
                        'Valid Move: ✅',
                        debug,
                        level,
                        this.TURNS,
                        this.CELL,
                        isWinner.cell,
                        isWinner.next || isWinner.winner
                    )
                    return isWinner //  Returns False or Draw or P1 or P2
                }
            }

            // Check if move is / has Valid Move, and if value move, return the updated token from grid
            return __hasValidMove(index, debug, level )
        }

        // ======================= ================================ ==================================
        // ======================= PRIVATE FUNCTIONS: CHECKWINNER() ==================================
        // ======================= ================================ ==================================

        /**
         * Checks whether the sequence of turns is a winner.
         * @design
         *   - Uses default/optional parameter values for function variable defaults.
         *   - Uses RegExp to check for a winning sequence and search sequences.
         *   - G mode global search for all instances rather than stopping at the 1st instance.
         *   - Filter for testing for empty characters in the turns string that are not present in the
         *     sequence string.
         *   - Returns true if the filtered string contains a sequence of three consecutive characters
         *     that matches the sequence string, and false otherwise.
         * @function _checkSequenceWin
         * @private
         * @access private
         * @param {string} streak - The current sequence streak of turns.
         * @param {string} sequence - The sequence of turns to check.
         * // Uses default/optional parameter values for function variable defaults.
         * @param {boolean} [debug=this.DEVMODE] - Optional Flag to enable debug mode.
         * @param {number} [level=this.LOGLEVEL] - Optional level of logging to console.
         * @returns {boolean}
         * @desc It takes in two parameters: turns and sequence.  Inside the function, it creates a
         *     regular expression using the sequence parameter. This regular expression matches any
         *     three characters in the sequence string. Then, it uses the created regular expression to
         *     filter out any characters in the turns string that are not present in the sequence
         *     string. The filtered string is stored in the filteredTurns variable. Finally, the
         *     function returns true if the filtered string contains a sequence of three consecutive
         *     characters that match the sequence string, and false otherwise.
         * @credit Scott Window for use of RegExp constructor, regex pattern and RegExp.test() methods.
         * */
        _checkSequenceWin(streak, sequence,
                          debug = this.DEVMODE, level = this.LOGLEVEL)
        {
            // Extract the sequence of turns that match the sequence string
            const sequenceRegExp =
                new RegExp(`[${sequence}]{${GameLogic.REG_SEARCH_LENGTH}]`)
            // Search for any empty characters in the turns string
            // that are not present in the sequence string
            const searchRegExp =
                new RegExp(`[^${sequence}]+`, GameLogic.REG_SEARCH_ALL)
            // replaces the characters found in the streak string that match the searchRegExp pattern.
            // Filters out any characters in the streak string that are not in the sequence string.
            const filteredTurns =
                streak.replace(searchRegExp, GameLogic.REG_SEARCH_FILTER)
            // Logs to the console the algorithm/regex for
            // inspecting the WIN_COMBINATION individual sequence.
            this._console(
                'checkSequenceWin: ✅',
                debug,
                level,
                streak,
                sequence,
                sequenceRegExp,
                searchRegExp,
                filteredTurns
            )
            // Returns true if the filtered string contains a sequence of three consecutive characters
            return sequenceRegExp.test(filteredTurns)
        }

        // =========================================== ================================ ===============
        // ===========================================  PUBLIC FUNCTION: CHECKWINNER()  ===============
        // =========================================== ================================ ===============

        /**
         * Checks if the sequence of turns, assigns a winner, AND end state flag: False, Draw, P1, P2.
         * @design
         *   - Loops over the list of winning sequences and calls the _checkSequenceWin method
         *   - Loops over winning combinations to check if either player has won.
         *   - For each xTurn/oTurn, it calls the _checkSequenceWin method to check if the sequence of
         *     turns is a winner.
         *   - If Player 1 has won, the won variable is set to GameLogic.P1 (indicating Player 1's
         *     victory).
         *   - If Player 2 has won, the won variable is set to GameLogic.P2 (indicating Player 2's
         *     victory).
         *   - The method returns the value of the won variable, indicating the winner of the game or
         *     default value: false/
         *   - Logs to the console the algorithm/regex for inspecting the WIN_COMBINATION individual
         *     sequence.
         * @function checkWinner
         * @public
         * @access public
         * @internal @function: __checkPlayerWin
         * @param {boolean} [debug=this.DEVMODE] - Optional Flag to enable debug mode.
         * @param {number} [level=this.LOGLEVEL] - Optional level of logging to console.
         * @returns {boolean|string} Returns false or the player string: P1, P2 (as truthy values).
         * @desc checks for a winner in a game. It iterates over a list of winning sequences and calls
         *     the
         * _checkSequenceWin method to check if either player has won.
         * If Player 1 has won, the won variable is set to GameLogic.P1 (indicating Player 1's
         *     victory).
         * If Player 2 has won, the won variable is set to GameLogic.P2 (indicating Player 2's
         *     victory).
         * The method returns the value of the won variable, indicating the winner of the game.
         * @complexity 53%
         * */

        checkWinner(debug = this.DEVMODE,
                    level = this.LOGLEVEL)
        {
            // Type cast to Strong from GameLogic.TURN_RESET (Is a string ty)
            let xMoves = this._xTurns.toString()
            let oMoves = this._oTurns.toString()

            let whos_moves  = [xMoves, oMoves]
            let players = [GameLogic.P1, GameLogic.P2];

            // This is your closure or inner function
            /**
             * Checks if any player wins based on the given turns and sequence.
             * @function __checkPlayerWin
             * @param {string[]} current_move - The array of turns by all players.
             * @param {string} sequence - The winning sequence to check against.
             * @returns {boolean|string} - Returns the winning player or false if no player wins.
             */
            const __checkPlayerWin = (current_move,
                                      sequence) => {
                for(let who = 0; who < current_move.length; who++){
                    if (this._checkSequenceWin(current_move[who], sequence)) {
                        this.IFWON = players[who]
                        this._console(
                            `checkWinner: ✅: Player: ${this.IFWON}`,
                            debug,
                            level,
                            current_move[who],
                            sequence,
                            this.IFWON
                        )
                        return this.IFWON // i.e. {string}: P1 || P2 (not commented out code)
                    }
                }
                return false; // Return false if no player wins
            }

            // Loop over the list of winning sequences and check if either player has won
            for (const sequence of this.WIN_SEQUENCE) {
                let playerWin = __checkPlayerWin(whos_moves,
                                                 sequence);

                // If a player has won, return
                if (playerWin){
                    return playerWin;
                }

                // If no player has won yet i.e. (playerWin ==== false)
                this.IFWON = GameLogic.IN_PLAY // Game in play
                // Log to console.
                this._console(
                    `checkWinner: ✅: Game In Play: ${this.IFWON},`
                    + `Current Sequence ${sequence}`,
                    debug,
                    level,
                    sequence,
                    this.IFWON
                )
                this._console('Next Turn', debug, 1)
            }

            return this.IFWON
            // Game in play or P1 or P2 wins (should be only game in play at this point)
        }

        /**
         * Checks if there is a winning play in the game.
         * @design
         *   - Uses internal functions for complex conditional boolean logic.
         *   - Use internal function to be DRY and improve maintainability/readability using named
         *     functions/intent.
         *   - Uses default/optional parameter values for function variable defaults.
         *   - Use class properties to set the IFWON state.
         *   - Logs to console the function parameters and return values for debugging purposes when
         *     debug mode is enabled.
         * @function checkWinningPlay
         * @public
         * @access public
         * @param {boolean} [debug=this.DEVMODE] - Optional Flag to enable debug mode.
         * @param {number} [level=this.LOGLEVEL] - Optional level of logging to console.
         * @return {string} - The current state of the game.
         *   - Possible values are GameLogic.P1 (X), GameLogic.P2 (Y), GameLogic.IN_PLAY (false).
         * @complexity 46%
         */
        checkWinningPlay(debug = this.DEVMODE,
                         level = this.LOGLEVEL) {
            /**
             * Assigns the winner of a game.
             * @private
             * @function _assignWinner
             * @param {string} current_moves - The number of turns taken in the game.
             * @param {string} sequence - The sequence of moves made in the game.
             * @param {string} winner - The winner of the game.
             * @param {boolean} debug - Indicates whether debug mode is enabled.
             * @param {number} level - The level of debugging (0 for basic, 1 for detailed).
             * @returns {boolean} - Returns true if the winner was assigned, false otherwise.
             */
            const _assignWinner = (current_moves, sequence, winner,
                                   debug, level) => {
                if (this._checkSequenceWin(current_moves, sequence)) {
                    this.IFWON = winner
                    this._console(
                        `checkWinner: ✅: Player: ${this.IFWON}`,
                        debug,
                        level,
                        current_moves,
                        sequence,
                        this.IFWON
                    )
                    return true
                }
                return false
            }

            /**
             * Sets IFWON to current and logs the game status, for current game round.
             * @private
             * @function _defaultRound
             * @param {Array} sequence - The game sequence.
             * @param {boolean} current - The current game status.
             * @param {boolean} debug - Whether to enable debug logging.
             * @param {number} level - The logging level.
             * @returns {void}
             */
            const _defaultRound = (sequence, current,
                                   debug, level) => {
                this.IFWON = current
                this._console(
                    `checkWinner: ✅: Game In Play: ${this.IFWON}`,
                    debug,
                    level,
                    sequence,
                    current
                )
            }

            // Loop over the sequence of winning combinations and
            // assign the winner according to the winning sequence.
            for (const sequence of this.WIN_SEQUENCE) {
                if (_assignWinner(this._xTurns, sequence,
                                  GameLogic.P1, debug, level)) {
                    break // Break loop only is PLayer 1 wins, and assign to IFWON
                } else if (_assignWinner(this._oTurns, sequence,
                                         GameLogic.P2, debug, level)) {
                    break // Break loop only is PLayer 2 wins, and assign to IFWON
                } else {
                    _defaultRound(sequence, GameLogic.IN_PLAY,
                                  debug, level)
                    // i.e. 'continue' is not unnecessary at last statement in loop (not code)
                } // Default state, no winner

                // No else part needed as IFWON default state is already set
            }
            return this.IFWON // Returns the game states: False or P1 or P2 wins.
        }

        // ======================== ================================ ==================================
        // ========================   PUBLIC FUNCTIONS: RESET()      ==================================
        // ======================== ================================ ==================================

        /**
         * Reset the game state to its initial values using Class Constants (properties).
         * @design
         *   - Reset the game state to its initial values using Class Constants (properties).
         *   - Uses Class contances to reset the game state for the current instance.
         *   - Logs to the console to validate the game state on reset
         * @function reset
         * @public
         * @access public
         * @param {boolean} [debug=this.DEVMODE] - Optional Flag to enable debug mode.
         * @param {number} [level=this.LOGLEVEL] - Optional level of logging to console.
         * @return {void}
         * @desc that resets the game state to its initial values.
         * - Resets turns to a predefined value
         * - Reset won to false.
         * - Reset grid to an empty array.
         * - Reset _xTurns and _oTurns to empty strings.
         * */
        reset(debug = this.DEVMODE, level = this.LOGLEVEL) {
            this._currentcell = GameLogic.CELL_RESET
            this._grid = GameLogic.NEW_GRID
            this._draw = GameLogic.NO_DRAW
            this._won = GameLogic.IN_PLAY
            this._turns = GameLogic.TURN_INIT
            this._xTurns = GameLogic.TURN_RESET
            this._oTurns = GameLogic.TURN_RESET
            // Logs to the console for the instance  variables on reset class instance.
            this._console(
                'Reset:✅',
                debug,
                level,
                this._currentcell,
                this._grid, // Initial/end grid properties.
                this._draw,
                this._won, // Initial/end game state properties.
                this._turns,
                this._xTurns,
                this._oTurns // Initial/end turn properties.
            )
        }
    }

let board = new GameLogic(true, 1);
console.log('Game Board: ', board._grid);

</script>
<script>
    // Alpine.store('game', GameLogic());
    Alpine.store('game', new GameLogic(true, 1),);
</script>

</body>
</html>
