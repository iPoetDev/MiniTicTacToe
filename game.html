
<!DOCTYPE html>
<!--suppress ALL -->
<html lang="en">
<head>
    <title>Tic Tac Toe : AlpineJS by Scott Windon </title>
    <meta charset="UTF-8"> <!-- Character Encoding -->
    <!-- Required Meta Tags -->
    <meta content="width=device-width, initial-scale=1"
        name="viewport"> <!-- Responsive Design -->
    <!-- Recommended Meta Tags -->
    <meta content="Example AlpineJS Tic Tac Toe: Scott Windon"
        name="description"> <!-- SEO Meta Description -->
    <meta content="your, tags"
        name="keywords"> <!-- SEO Keywords -->
    <meta content="author name"
        name="author"> <!-- Author Information -->
    <!-- Links to CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="docs/assets/css/style.css"
        rel="stylesheet">
    <script defer src="https://cdn.jsdelivr.net/npm/alpinejs@3.13.3/dist/cdn.min.js"></script>
    <script>
        window.onload = function() {
            //Alpine.start();
        };
    </script>
</head>
<!--                                                                         -->
<body>
<!--suppress GrazieInspection -->
<div class="min-w-screen min-h-screen bg-gray-800 flex items-center justify-center px-5 py-5">
    <!--
        The x-data directive is used to create a new instance of the gameApp object;
            - using an assignment to a local variable.
    -->
    <div class="w-96 h-96 mx-auto text-indigo-500 rounded-md flex flex-wrap relative"
        title=""
        x-data="{ game: board }" x-init="console.log('Game Board: Init:', board );">
        <!--suppress GrazieInspection -->
        <div class="flex w-full h-1/3">
        <!--
            The x-for directive is used to create, via grid array loops, & display the game grid's first row.
            The x-text directive is used to display the value of the item in the grid array.
            The x-show directive is used to hide the value of the item in the grid array.
            The x-transition directive is used to animate the display of the value of the item in the grid array.
        -->
            <template x-for="(item, index) in game.grid.slice(0,3)" :key="index">
                <div class="border-b border-gray-700 w-1/3" :class="{'border-l':index>0}">
                    <button class="w-full h-full outline-none focus:outline-none text-8xl leading-none"
                            @click.prevent="
                                // Select the item in the grid array at the specified index
                                game.grid[index] = game.select(index),
                                /**
                                 * The $nextTick method is used to wait for the DOM to be updated
                                 * before updating the grid array with the selected item.
                                 * Combined with Alpine.reactive() on the game.grid array in App class.
                                 * @url https://alpinejs.dev/magics/nextTick
                                 * @url https://alpinejs.dev/advanced/reactivity
                                 */
                                $nextTick(() =>
                                    // Updated select the item in the grid array at the specified index.
                                    game.grid[index] = game.grid[index],
                                    // Logging Confirm of successful event update
                                    console.log('grid update:', game.grid[index])
                                )
                                ">
                        <!--suppress XmlUnboundNsPrefix -->
                        <!--
                            The x-show directive: showing the game.grid[index] value when the grid is not null.
                            The x-text directive: displaying the game.grid[index] value when the grid is not null
                                - Default: x-text is assigned on template/#doc-fragment rendering.
                                - x-text does not automatic DOM update.
                            The x-transition directive is used to animate the display of the value of the item in
                            the grid array.
                        --->
                        <span class="inline-block"
                            x-show="game.grid[index]!==null" x-text="game.grid[index]"
                            x-transition:enter="transition ease-out duration-300"
                            x-transition:enter-start="opacity-0 transform scale-50"
                            x-transition:enter-end="opacity-100 transform scale-100"></span>
                    </button>
                </div>
            </template>
        </div>
        <div class="flex w-full h-1/3">
            <!--
            âž– The AlpineJS x-for directive: to create, via grid array loops, & display the game grid's third row.
            âž– Loops on the AlpineJs key: index and creates a row for cells 4 to 6 as clickable buttons.
            âž– @click event: to select the item in the grid array at the specified index
            -->
            <template x-for="(item, index) in game.grid.slice(3,6)" :key="index">
                <div class="border-b border-gray-700 w-1/3" :class="{'border-l':index>0}">
                    <button class="w-full h-full outline-none focus:outline-none text-8xl leading-none"
                            @click.prevent="
                                game.grid[index+3] = game.select(index+3),
                                $nextTick(() =>
                                    game.grid[index+3] = game.grid[index+3],
                                    // Logging Confirm of successful event update
                                    console.log('grid update:', game.grid[index+3])
                                )">
                        <span class="inline-block"
                            x-show="game.grid[index+3]!==null" x-text="game.grid[index+3]"
                            x-transition:enter="transition ease-out duration-300"
                            x-transition:enter-start="opacity-0 transform scale-50"
                            x-transition:enter-end="opacity-100 transform scale-100"></span>
                    </button>
                </div>
            </template>
        </div>
        <div class="flex w-full h-1/3">
            <!--
            âž– The AlpineJS x-for directive: to create, via grid array loops, & display the game grid's third row.
            âž– Loops on the AlpineJs key: index and creates a row for cells 7 to 9 as clickable buttons.
            âž– @click event: to select the item in the grid array at the specified index
            -->
            <template x-for="(item, index) in game.grid.slice(6, 9)" :key="index">
                <div class="border-b border-gray-700 w-1/3" :class="{'border-l':index>0}">
                    <button class="w-full h-full outline-none focus:outline-none text-8xl leading-none"
                            @click.prevent="
                                game.grid[index+6] = game.select(index+6),
                                $nextTick(() =>
                                    game.grid[index+6] = game.grid[index+6],
                                    // Logging Confirm of successful event update
                                    console.log('grid update:', game.grid[index+6])
                                )
                            ">
                        <span class="inline-block"
                            x-show="game.grid[index+6]!==null" x-text="game.grid[index+6]"
                            x-transition:enter="transition ease-out duration-300"
                            x-transition:enter-start="opacity-0 transform scale-50"
                            x-transition:enter-end="opacity-100 transform scale-100"></span>
                    </button>
                </div>
            </template>
        </div>
        <button class="absolute top-0 left-0 w-96 h-96 flex items-center justify-center outline-none focus:outline-none"
                style="display:none;"
                x-show="game.WON()||game.TURNS()>=9"
                x-transition:enter="transition ease-out duration-300"
                x-transition:enter-start="opacity-0 transform scale-50 rotate-12"
                x-transition:enter-end="opacity-100 transform scale-100 rotate-0"
                @click.prevent="game.reset()">
            <span class="block transform -rotate-12 text-white text-9xl text-glow-xl"
                x-text="game.WON()?'Winner!':'ðŸ˜”'"></span>
        </button>
    </div>
</div>


<!-- BUY SCOTT WINDON (originator of version 1 and concept) A BEER AND HELP SUPPORT OPEN-SOURCE RESOURCES -->
<!-- Accreditation for External Source Code, as foundational code for this project. -->
<div class="flex items-end justify-end fixed bottom-0 right-0 mb-4 mr-4 z-10">
    <div>
        <a class="block w-16 h-16 rounded-full transition-all shadow hover:shadow-lg transform hover:scale-110 hover:rotate-12"
           href="https://www.buymeacoffee.com/scottwindon" target="_blank"
           title="Buy me a beer: Scott Windon">
            <img class="object-cover object-center w-full h-full rounded-full"
                src="https://i.pinimg.com/originals/60/fd/e8/60fde811b6be57094e0abc69d9c2622a.jpg" alt="Buy ScottWindon a Coffee; tracker"/>
        </a>
    </div>
</div>

<script>

// noinspection GrazieInspection
class GameLogic {
    /**
     * Constructor for the App class.
     * Initializes the App object with default values and reactivity, for
     * - turns,
     * - win state,
     * - win sequences,
     * - game grid,
     * - x characters | o characters.
     * The constructor also logs the instantiation of the ...
     *      App object to the console.
     * @url https://alpinejs.dev/advanced/reactivity
     * @constructor
     * @this {GameLogic} - The GameLogic object.constructor
     * @method constructor
     */
    // noinspection FunctionNamingConventionJS
    constructor () {
        // Enable Developer Mode for debuugging
        this.DEBUG = this.DEVMODE
        // Instance variables set by Class Constants
        /** @instance CONSTANT */
        this._EMPTYCELL = GameLogic.CELL_RESET; // Set initial class constants empty cell.
        /** @instance private */
        this._turns = GameLogic.TURN_INIT
        /** @instance private */
        this._won = GameLogic.IN_PLAY // The default check win state of the game / Set initial constants
        /** @instance private */
        this._winSeq = GameLogic.WIN_COMBINATIONS // Set initial class constants
        // noinspection JSUnresolvedReference, ChainedFunctionCallJS, NestedFunctionCallJS
        /** @instance private */
        //this._grid = this.NEW_GRID
        this._grid = GameLogic.NEW_GRID
        // noinspection JSUnresolvedReference
        /** @instance private */
        this._xChars = GameLogic.P1_TOKENS
        // noinspection JSUnresolvedReference
        /** @instance  private */
        this._oChars = GameLogic.P2_TOKENS
        /** @instance  private */
        this._xTurns = GameLogic.TURN_RESET // Set initial class constants
        /** @instance private */
        this._oTurns = GameLogic.TURN_RESET // Set initial class constants
        console.log('Instantiate App:', this) // jshint ignore:line
    }
    // =========================================== PROPERTY GET/SET | CLASS DEBUG MODE ===============================

    /**
     * Retrieves the current value of the DEVMODE property.
     * @property {boolean} DEVMODE
     * @public
     * @returns {boolean} The current value of the DEVMODE property.
     * @default false
     */
    get DEVMODE () {
        return false
    }

    /**
     * Sets the developer mode toggle.
     * @property {boolean} DEVMODE
     * @public
     * @param {boolean} toggle - The value to set the developer mode toggle.
     * @default {boolean} false` if `toggle` is undefined.
     */
    set DEVMODE (toggle) {
        this.DEBUG = toggle === undefined ? false : toggle;
    }

    // =========================================== PROPERTY STATIC GETTERS | CLASS Contants =========================

    /**
     * Gets the Player 1 Token.
     * @property {string} P1 Player 1 Token
     * @private
     * @returns {string} The name of the property for turns.
     * @static, Class constants
     * @default 'X'
     */
    static get P1 () {
        return 'X'
    }

    /**
     * Get the P1 tokens.
     * @property P1_TOKENS
     * @private
     * @returns {Array} The P1 tokens.
     * @static, Class constants
     */
    static get P1_TOKENS () {
        return ['x', 'X']
    }

    /**
     * Gets the Player 1 Token.
     * @property {string} P2 Player 2 Token
     * @private
     * @returns {string} The name of the property for turns.
     * @static, Class constants
     * @default 'O'
     */
    // noinspection FunctionNamingConventionJS
    static get P2 () {
        return 'O'
    }

    /**
     * Get the P2 tokens.
     * @property {Array} P2_TOKENS
     * @private
     * @returns {Array} The P2 tokens.
     * @static, Class constants
     */
    static get P2_TOKENS () {
        return ['o', 'O']
    }

    /**
     * Returns an array of winning combinations on a Tic-Tac-Toe board.
     * The combinations are represented by strings of three positions on the board.
     * Each position is denoted by a number from 0 to 8, indicating the index of the position on the board array.
     * The winning combinations consist of three positions that form a winning row, column, or diagonal on the board.
     * @property {Array} WIN_COMBINATIONS
     * @private
     * @return {Array} The array of winning combinations.
     * @static, Class constant
     */
    static get WIN_COMBINATIONS () {
        return [
            '012',
            '345',
            '678', // HorizontalWins
            '036',
            '147', // DiagonalWins
            '258',
            '048',
            '246',
        ]
    }

    /**
     * Retrieves the current state of the game.
     * @property {boolean} IN_PLAY - The inital/current state of the game when not won.
     * @private
     * @return {boolean} - Whether the game is currently in play or not.
     * @static, Class constant
     * @default false
     */
    static get IN_PLAY () {
        return false
    }

    /**
     * Returns the reset value for the cell.
     * @property {null} CELL_RESET
     * @private
     * @returns {null} The reset value for the cell.
     * @static, Class constant
     * @default null
     */
    static get CELL_RESET () {
        return null
    }

    /**
     * Retrieves the value representing the turn reset.
     * @property {string} TURN_RESET
     * @private
     * @returns {string} The value representing the turn reset.
     * @static, Class constant
     */
    static get TURN_RESET () {
        return ''
    }

    /**
     * Gets the name of the property for keeping track off the number of X turns.
     * @property {string} X_TURNS_PROP
     * @private
     * @returns {string} The name of the property for X turns.
     * @static, Class constant
     */
    // noinspection FunctionNamingConventionJS
    static get X_TURNS_PROP () {
        return '._xTurns'
    }

    /**
     * Gets the name of the property for keeping track of the number of O turns.
     * @property {string} O_TURNS_PROP
     * @private
     * @returns {string} The name of the property for O turns.
     * @static, Class constant
     */
    // noinspection FunctionNamingConventionJS
    static get O_TURNS_PROP () {
        return '._oTurns'
    }

    /**
     * Returns the maximum (array/grid cell) length allowed for the grid
     * @property {number} MAX_LENGTH
     * @private
     * @returns {number} The maximum length allowed.
     * @static, Class constant
     * @default 9 - max size of a game of tic tac toe
     */
    // noinspection FunctionNamingConventionJS
    static get MAX_LENGTH () {
        return 9
    }
    /**
     * Returns the initialisation value for turns.
     * @property {number} TURN_INIT
     * @private
     * @returns {number} The value for TURN_INIT.
     * @static, Class constant
     * @default 0 - Initialisation for turns.
     */
    // noinspection FunctionNamingConventionJS
    static get TURN_INIT () {
        return 0
    }

    // =========================================== PROPERTY PUBLIC GETTERS ===========================================

    /**
     * Returns the initialisation value for turns.
     * @property {array} GRID
     * @access public
     * @returns {array} The value for private _grid.
     */
    get GRID () {
        return this._grid
    }

    set NEW_GRID () {
        return new Array(GameLogic.MAX_LENGTH).fill(GameLogic.CELL_RESET)
    }

    /**
     * Returns the default value for WIN state or winning Player for instance variable _won.
     * @property {boolean, string} IFWON
     * @access public
     * @returns {boolean, string} The value for private instance member _won.
     * @default {boolean} false
     */
    get IFWON () {
        return this._won
    }

    /**
     * Sets the value for _won.
     * @property {boolean, string} IFWON
     * @access public
     * @param {boolean, string} value The value to set for _won.
     * @default {boolean} false
     */
    set IFWON (value) {
        this._won = value === undefined ? false : value;
    }

    /**
     * Returns the initialisation value for turns.
     * @property {number} TURNS
     * @access public
     * @returns {number} The value for current private _turns.
     */
    get TURNS () {
        return this._turns
    }

    /**
     * Returns the maximum turn value. Array length - 1.
     * @property {number} MAX_TURNS
     * @access public
     * @return {number} The maximum turn value.
     */
    get MAX_TURN () {
        return this._grid.length - 1
    }

    /**
     * Retrieves the value of a cell in the grid based on a given index.
     * @function currentCELL accessor function
     * @param {number} index - The index of the cell to retrieve.
     * @return {*} - The value of the cell at the specified index.
     */
    currentCELL(index) {
        return this._grid[index]
    }

    /**
     * Sets the value of a cell in the grid based on a given index.
     * @property {number} CELL - The grid's index of the cell to set.
     * @param {number} index - The index of the cell to set.
     * @param {*} value - The value to set the cell to.
     */
    set CELL({ index, value }) {
        this._grid[index] = value;
    }

    // =========================================== PRIVATE FUNCTIONS: HELPERS =======================================

    /**
     * Logs a message to the console based on the specified debug and verbosity level.
     * @design LOGGING TO CONSOLE IS AN INTENTIAL DESIGN FEATURE THAT IS CONTROLED BY THE DEBUG MODE & VERBOSITY FLAG.
     * @function _console logger according to debug mode and verbosity level
     * @private
     * @access private
     * @param {string} message - The message to be logged.
     * @param {boolean} [debug=false] - Indicates whether debug mode is enabled.
     * @param {number} [verbosity=0] - The verbosity level for the log message.
     * @param {...any} [args] - Additional arguments to be passed to the console methods.
     * @return {void}
     * @desc It takes in four parameters: message, debug, verbosity, and args.
     * It checks if debug is enabled, and if it is, it outputs the message to the console based on the verbosity level.
     * Verbosity level 0: Clears the console (default)
     * Verbosity level 1: Logs the message to the console.
     * Verbosity level 2: Logs the message to the console using console.debug.
     * Verbosity level 3: Logs the message to the console using console.trace.
     * Verbosity level 4: Logs the message to the console using console.warn.
     * Verbosity level 5: Logs the message to the console using console.error.
     * Verbosity level 6: Logs the message to the console using console.dir.
     */
    _console(message, debug = false, verbosity = 0, ...args) {
        // check if debug is enabled
        if (!debug) return;

        // output messages based on verbosity level
        switch (verbosity) {
            case 1:
                console.log(message, ...args);
                break;
            case 2:
                console.debug(message, ...args);
                break;
            case 3:
                console.trace(message, ...args);
                break;
            case 4:
                console.warn(message, ...args);
                break;
            case 5:
                console.error(message, ...args);
                break;
            case 6:
                console.dir(message, ...args);
                break;
            default:
            // do nothing for default. If true, and level is not used, clears the console.
                console.clear();
        }
    }

    // =========================================== PRIVATE FUNCTIONS: SELECT() =======================================

    /**
     * Returns a random character from the given character array.
     * @design
     *  This randomiser allows variation of the game token sizes (lower case/upper case).
     *  It mimics variation in hand strokes when hand drawing the game tokens.
     * @function _getRandomCharacter
     * @private
     * @access private
     * @param {Array} characterArray - The array containing characters.
     * @return {string} - A random character from the character array.
     */
    // noinspection FunctionNamingConventionJS
    _getRandomCharacter (characterArray, debug = false, level = 0) {
        // noinspection LocalVariableNamingConventionJS,NestedFunctionCallJS
        /** An inner function/closure for generating a random index. Improve maintainability/readability.
         * @function {arrow function} _getRandomIndex
         * @param {number} arrayLength
         * @return {number} - A random index.
         */
        const _getRandomIndex = arrayLength => Math.floor(Math.random() * arrayLength)
        const index = _getRandomIndex(characterArray.length)
        this._console('getRandomCharacter: ', debug, level,
                      characterArray, index, characterArray[index])
        return characterArray[index]
    }

    /**
     * Update the turns and grid at the specified index
     * with a random character from the characterArray.
     * @function _updateTurnsAndGrid
     * @private
     * @access private
     * @param {number} index - The index of the grid to update.
     * @param {Array} characterArray - The array of characters to choose from.
     * @param {string} turnProperty - The property to update the turns with.
     * @return {undefined}
     * @desc It takes in three parameters: index, characterArray, and turnProperty.
     * It updates the grid array at the specified index with a random character from the characterArray and ...
     * increments the value of the turnProperty by index.
     */
    _updateTurnsAndGrid (index, characterArray, turnProperty, debug = false, level = 0) {
        // Set the current CELL (grid item) to a random character from the characterArray
        this.CELL[index] = this._getRandomCharacter(characterArray);
        // Update the turnProperty by index
        this[turnProperty] += index
        this._console('updateTurnsAndGrid: ', debug, level,
                      index, characterArray, turnProperty, this[turnProperty], this.CELL[index])
    }

    /**
     * Checks if the given move is invalid.
     * @design
     *   - Has an inner function to DRY check the multiple invalid states:
     *      1) If Won, or 2) If Cell is not empty, or 3) IF turn COUNT is greater than or equal to playable MAX_TURNs.
 *       - Use as a flag to check for type of moves (invalid or valid) and to return the current state of the game.
     *   - Logs to console the function parameters and return values for debugging purposes when debug mode is enabled.
     * @function _isInvalidMove
     * @private
     * @access private
     * @param {number} index - The index of the move.
     * @param {boolean} debug - Flag to enable debug mode.
     * @param {number} level - The level of debug mode.
     * @returns {boolean} - Returns true if the move is invalid, false otherwise.
     * @description Checks if a given move is invalid. The function takes an index as an argument and returns true if the
     * move is invalid, and false otherwise.
     * The move is considered invalid if any of the following conditions are met: the game is already won, the
     * grid at the given index is not null, or the number of turns is greater than or equal to the maximum index.
     */
    _isInvalidMove (index, debug, level = 0) {

        /**  // Inner function declaration (restrict for scope)
         * Determines if the current state is invalid.
         * @function _hasInvalidState
         * @param {number} index - The index of the cell.
         * @param {number} max_turn - The maximum number of turns allowed.
         * @param {boolean} debug - Indicates whether debugging is enabled.
         * @param {number} level - The level of debug mode.
         * @return {boolean} - True if the current state is invalid, false otherwise.
         */
        const _hasInvalidState = (index, max_turn) => {
            return this.IFWON ||
                this.currentCELL(index) !== this._EMPTYCELL || // if not null, truthy for false
                this.TURNS >= max_turn; // More than max turns, truthy for false
        };
        // Log to Function Params to Console for debugging purposes when debug mode is enabled.
        this._console('isInvalidMove:â“: ', debug, level,
                      index, this.IFWON, this.currentCELL(index), this.TURNS, this.MAX_TURN);
        // Checks the current state for invalidity from inner function
        const ifInvalidMove = _hasInvalidState(index, this.MAX_TURN);
        // Log to Function Return to Console for debugging purposes when debug mode is enabled.
        this._console('isInvalidMove:âœ…: ', debug, level,
                      ifInvalidMove)
        return ifInvalidMove;
    }

    /**
     * Determines if the turn is even and updates the turns and grid accordingly.
     * @design:
     *  - Uses anonymous arrow functions to DRY the code over direct const assignments.
     *  - Improve maintainability/readability.
     *  - Uses Modulus 2 to determine if the turn is even.
     *  - Uses a ternary operator to assign the character and property to be used.
     *  - Calls the _updateTurnsAndGrid method to update the turns and grid based the character and turn properties.
     *  - Logs to console the function parameters and return values for debugging purposes when debug mode is enabled.
     * @function _isEvenTurn
     * @private
     * @access private
     * @param {number} index - The index of the grid to be updated.
     * @return {undefined}
     * @desc determines if the turn is even and updates the turns and grid accordingly.
     * It takes an input parameter index which represents the index of the grid to be updated.
     * It calculates whether the turn is even by checking if the remainder of the division of `this._turns`
     * by 2 is equal to 0. If the turn is even, it assigns certain values to variables char and prop.
     */
    _isEvenTurn (index, debug = false, level = 0) {

        // Determines if the turn is even
        const _isTurnEven = () => { return this.TURNS % 2 === 0; }
        // Chooses the character to be used
        const _chooseChar = () => { return _isTurnEven() ? this._xChars : this._oChars; }
        // Selects the token to be used
        const _selectProp = () => { return _isTurnEven() ? GameLogic.X_TURNS_PROP : GameLogic.O_TURNS_PROP; }
        // Update the turns and grid
        this._updateTurnsAndGrid(index, _chooseChar, _selectProp)
        // Log to Function Return to Console for debugging purposes when debug mode is enabled.
        this._console('isEvenTurn:âœ…', debug, level,
                      _chooseChar, _selectProp, index, this.currentCELL(index)) // jshint ignore:line
    }

    /**
     * Increments the value of the TURNS property by 1.
     * @function _incrementTurn
     * @private
     * @access private
     * @return {void}
     */
    _incrementTurn() {
        this._turns += 1;
    }

    // =========================================== ================================ ==================================
    // ===========================================    PUBLIC FUNCTIONS: SELECT()    ==================================
    // =========================================== ================================ ==================================
    /**
     * Selects a cell, bu index, on the game board.
     * @design:
     *   - Main interface method for the user interface and game board.
     *   - Uses an inner function to DRY the code over direct const assignments.
     *   - Inner function is used to determine who wins based on the given index, and returns the state of the game.
     *   - Logs to console the function parameters and return values for debugging purposes when debug mode is enabled.
     *   - 3 Game States (on return): Based on a current cell, next play, game state and game message.
     *     - Invalid Move: Try again
     *     - Next Play: Game in play
     *     - Winning State: P1 or P2 wins
     * @function select
     * @public
     * @access public
     * @param {number} index - The index of the cell to be selected.
     * @returns {object}:
     *   - cell: The current cell at the given index. (X or Y Token)
     *   - next: The next action to take after the move.
     *   - message: A message describing the reason for the invalid move.
     *   - state: Indicates if the game is still ongoing (false) or if someone has won (true).
     *   - outcome: The outcome of the move (0 - invalid move, 1 - valid move)
     * @desc  It logs the selected index, checks if the move is invalid, and returns the game token for X or Y.
     *   - If the move is invalid, it logs an error message and returns the current item from the grid. //
     *   - If the move is valid, it updates the turns and grid, checks if the game has been won, logs a success message,
     *   - and returns the updated item/token from the grid.
     * */
    select (index, debug = false, level = 0) {

        /**
         * Determines who wins based on the given index.
         * @design
         *  - Uses an inner function to DRY the code over direct const assignments.
         *  - Inner function simplifies the multipe end states of the valid move: 1) Game in play, 2) Game won.
         *  - Returns: Current cell, next turn, game message v winner, game state and game outcome.
         *  - Logs to console the function parameters for debugging purposes when debug mode is enabled.
         * @private
         * @internal
         * @function _whoWins
         * @param {number} index - The index of the move being checked.
         * @param {boolean} debug - Indicates whether debug mode is enabled.
         * @param {number} level - The difficulty level of the game.
         * @returns {Object} - An object containing information about the validity of the move.
         *   - cell: The current cell at the given index.
         *   - next: The next action to take after the move.
         *   - message: A message describing the reason for the invalid move.
         *   - state: Indicates if the game is still ongoing (false) or if someone has won (true).
         *   - outcome: The outcome of the move (0 - invalid move, 1 - valid move).
         */
        const _whoWins = (index, debug, level) => {
            if (!this.checkWinner()) {
                this._console('isWinner: âŒ', debug, level,
                              index, this.currentCELL(index), this.checkWinner()) // jshint ignore:line
                return {
                    cell: this.currentCELL(index), // Current cell in play
                    next: 'Next Turn',
                    message: 'Game in play',
                    state: false, // Game is not won, continuing
                    outcome: 0
                }
            } else {
                this._console('isWinner: âœ…', debug, level,
                              index, this.currentCELL(index), this.checkWinner() ) // jshint ignore:line
                return {
                    cell: this.currentCELL(index), // Winning cell when played.
                    next: 'Game Over',
                    winner: this.checkWinner() ? this.checkWinner() : "No Winner" , // When P1 or P2 is returned the winner.
                    state: true, // Game is won, end game.
                    outcome: 1
                }
            }
        }

        /**
         * Checks if a move is valid or not.
         * @design
         * @private
         * @internal
         * @function _hasValidMove
         * @param {number} index - The index of the move being checked.
         * @param {boolean} debug - Indicates whether debug mode is enabled.
         * @param {number} level - The difficulty level of the game.
         * @returns {Object} - An object containing information about the validity of the move.
         *   - cell: The current cell at the given index.
         *   - next: The next action to take after the move.
         *   - message: A message describing the reason for the invalid move.
         *   - state: Indicates if the game is still ongoing (false) or if someone has won (true).
         *   - outcome: The outcome of the move (0 - invalid move, 1 - valid move).
         */
        const _hasValidMove = (index, debug, level) => {
            if (this._isInvalidMove(index)) {
                // Invalid Moves: Try again.
                this._console('Invalid Move: ðŸš§', debug, level,
                              index) // jshint ignore:line
                return {
                    cell: this.currentCELL(index),
                    next: 'Try again',
                    message: 'Invalid Move: Select a different/empty slot',
                    state: false, // Game is not won, continuing
                    outcome: 2
                }
            } else {
                // Valid Move: Proceed to next turn or declare winner.
                // Update the turns and grid
                this._incrementTurn()
                this._isEvenTurn(index)
                // Check if the game has been won
                const isWinner = _whoWins(index, debug, level)
                // Return the updated item from grid
                this._console('Valid Move: âœ…', debug,  level,
                              this.TURNS, this.currentCELL(index),
                              isWinner.cell, (isWinner.next || isWinner.winner) )
                return isWinner // @Update 23/12/06 to return updated item/token from grid
                // Returns False or P1 or P2
            }
        }

        // Check if move is / has Valid Move, and if valud move, return the updated item/token from grid
        return _hasValidMove(index)
    }

    // =========================================== ================================ ==================================
    // =========================================== PRIVATE FUNCTIONS: CHECKWINNER() ==================================
    // =========================================== ================================ ==================================

    /**
     * Checks whether the sequence of turns is a winner.
     * @design
     *   - Uses default/optional parameter values for function variable defaults.
     *   - Uses RegExp to check for a winning sequence and seach sequences.
     *   - G mode global search for all instances rather than stopping at the 1st instance.
     *   - Fliter for testing for empty characters in the turns string that are not present in the sequence string.
     *   - Returns true if the filtered string contains a sequence of three consecutive characters that
     *     matches the sequence string, and false otherwise.
     * @function _checkSequenceWin
     * @private
     * @access private
     * @param {string} turns - The sequence of turns.
     * @param {string} sequence - The sequence of turns to check.
     * // Uses default/optional parameter values for function variable defaults.
     * @param {string} mode - ['g'] The mode to use for the regular expression. G is a global search.
     * @value {string} g: means regular expression will look for all instances rather than stopping at the 1st instance.
     * @param {string} filter - [''] The filter to use for the regular expression.
     * @param {boolean} debug - [false] Indicates whether debug mode is enabled.
     * @param {number} level - [0] The level of debug mode.
     * @returns {boolean}
     * @desc It takes in two parameters: turns and sequence.  Inside the function, it creates a regular expression
     * using the sequence parameter. This regular expression matches any three characters in the sequence string.
     * Then, it uses the created regular expression to filter out any characters in the turns string that are not
     * present in the sequence string. The filtered string is stored in the filteredTurns variable.
     * Finally, the function returns true if the filtered string contains a sequence of three consecutive characters
     * that match the sequence string, and false otherwise.
     * @credit Scott Window for use of RegExp constructor, regex pattern and RegExp.test() methods.
     * */
    _checkSequenceWin (turns, sequence, mode = 'g', filter = '', debug = false, level = 0) {
        // Extract the sequence of turns that match the sequence string
        const sequenceRegExp = new RegExp(`[${sequence}]{3}`)
        // Search for any empty characters in the turns string that are not present in the sequence string
        const searchRegExp = new RegExp(`[^${sequence}]+`, mode)
        const filteredTurns = turns.replace(searchRegExp, filter)
        // Logs to the console the algorithm/regex for inspecting the WIN_COMBINATION individual sequence.
        this._console('checkSequenceWin: âœ…', debug, level,
                      turns, sequence, sequenceRegExp, searchRegExp, filteredTurns)
        // Returns true if the filtered string contains a sequence of three consecutive characters
        return sequenceRegExp.test(filteredTurns)
    }

    // =========================================== ================================ ==================================
    // ===========================================  PUBLIC FUNCTION: CHECKWINNER()  ==================================
    // =========================================== ================================ ==================================

    /**
     * Checks if the sequence of turns, assins a winner, AND end state flag: False, P1, P2.
     * @design
     *   - Loops over the list of winning sequences and calls the _checkSequenceWin method
     *   - Loops over winning combinations to check if either player has won.
     *   - For each xTurn/oTurn, it calls the _checkSequenceWin method to check if the sequence of turns is a winner.
     *   - If Player 1 has won, the won variable is set to GameLogic.P1 (indicating Player 1's victory).
     *   - If Player 2 has won, the won variable is set to GameLogic.P2 (indicating Player 2's victory).
     *   - The method returns the value of the won variable, indicating the winner of the game or default value: false/
     *   - Logs to the console the algorithm/regex for inspecting the WIN_COMBINATION individual sequence.
     * @function checkWinner
     * @public
     * @access public
     * @param {boolean} debug - Indicates whether debug mode is enabled.
     * @param {number} level - The level of debug mode.
     * @returns {boolean or string} Returns false or the player string: P1, P2 (as truthy values).
     * @desc checks for a winner in a game. It iterates over a list of winning sequences and calls the
     * _checkSequenceWin method to check if either player has won.
     * If Player 1 has won, the won variable is set to GameLogic.P1 (indicating Player 1's victory).
     * If Player 2 has won, the won variable is set to GameLogic.P2 (indicating Player 2's victory).
     * The method returns the value of the won variable, indicating the winner of the game.
     * */

    checkWinner (debug = false, level = 0) {
        for (const sequence of this._winSeq) {
            if (this._checkSequenceWin(this._xTurns, sequence)) {
                this.IFWON = GameLogic.P1 // Player 1 wins | X wins
                this._console(`checkWinner: âœ…: Player: ${this.IFWON}`, debug, level,
                              this._xTurns, sequence, this.IFWON)
                break
            } // Player 1
            else if (this._checkSequenceWin(this._oTurns, sequence)) {
                this.IFWON = GameLogic.P2 // Player 2 wins | O wins
                this._console(`checkWinner: âœ…: Player: ${this.IFWON}`, debug, level,
                              this._oTurns, sequence, this.IFWON)
                break
            } // Player 2
            else {
                this.IFWON = GameLogic.IN_PLAY // Game in play
                this._console(`checkWinner: âœ…: Game In Play: ${this.IFWON}, Current Sequence ${sequence}`,
                              debug, level,
                              sequence, this.IFWON)
                break
            } // Default state, no winner
        }
        return this.IFWON // False or P1 or P2 wins
    }

    // =========================================== ================================ ==================================
    // ===========================================    PUBLIC FUNCTIONS: RESET()     ==================================
    // =========================================== ================================ ==================================

    /**
     * Reset the game state to its initial values using Class Constants (properties).
     * @design
     *   - Reset the game state to its initial values using Class Constants (properties).
     *   - Uses Class contances to reset the game state for the current instance.
     *   - Logs to the console to validate the game state on reset
     * @function reset
     * @public
     * @access public
     * @param {boolean} debug - Indicates whether debug mode is enabled.
     * @param {number} level - The level of debug mode.
     * @return {void}
     * @desc that resets the game state to its initial values.
     * - Resets turns to a predefined value
     * - Reset won to false.
     * - Reset grid to an empty array.
     * - Reset _xTurns and _oTurns to empty strings.
     * */
    reset (debug = false, level = 0) {
        this._turns = GameLogic.TURN_INIT
        this._won = GameLogic.IN_PLAY
        //this._grid = this.NEW_GRID
        this._grid = GameLogic.NEW_GRID
        this._xTurns = GameLogic.TURN_RESET
        this._oTurns = GameLogic.TURN_RESET
        // Logs to the console for the instance  variables on reset class instance.
        this._console('Reset:âœ…', debug, level,
                      this._turns, this._won, this._grid, this._xTurns, this._oTurns)
    }
}

let board = new GameLogic();
console.log('Game Board: ', board._grid);

</script>

</body>
</html>
